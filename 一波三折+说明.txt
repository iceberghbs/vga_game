--------------------------------- 功能 -------------------------------
btnU 复位
btnC 开始游戏
btnL 左移棍子
btnR 右移棍子
----------------------------------------------------------------------
--------------------------------- 流程 -------------------------------
复位后，小球在左上角，棍子在最左侧。
此时小球的速度是拨码开关的数值，与pdf描述一致。
按开始后，小球速度不再受拨码开关的控制，撞墙后，速度分量改变，撞北墙y轴速度反向，撞东西墙x反向，
如果撞南墙，那么游戏结束屏幕背景色变红，此时只能通过复位键对它进行复位，左右按键此时无法控制棍子。
游戏过程中，小球撞到棍子后反弹，并且分数加一。
分数在复位时为零，显示在数码管上，最高积分9999分，超过自动清零。

注意：在控制棍子时，如果棍子所移动的剩余空间不足，那么自动顶格，
比如说，棍子的单次移动为20，但右边剩余10个像素，那么按下btnR后，棍子只移动10格，贴墙。
----------------------------------------------------------------------
--------------------------------一波三折-----------------------------
一开始，先把课件里的球和棍子的静态显示实现。观察波形图，通过观察行同步信号hs和场同步信号vs与rgb信号，
确定了结果基本正确，但是打开sim文件夹发现，里面生成的bmp图案并不能正确显示。后来查看到vga_controller需要25Mhz的
pixel clock输入，但是在port map的时候直接连上了main的提供的时钟，而main的时钟在testbench中是接到100Mhz上的，所以
导致了生成图片的错误。解决办法是在调用main的时钟之前，在中间添加一个分频器，分频系数为4。

在得到正确的球和棍子的显示之后，我们将其变成动态的，我们定义球的坐标和棍子的左右两个边界为signal
（棍子无法上下活动，所以上下边界为常量）。
其余的墙壁的位置也定义为常量。

通过简单的输入btnL和btnR信号，我们成功让棍子动了起来。
但是球的更新速度是像素/帧，所以我们想到利用场同步信号来作为驱动球位置以及速度更新的时钟，这样做的好处是，
简单，并且避免了球在一帧更新的过程中有位置的变动，而引起球的“撕裂”。

在考虑控制棍子的移动时，虽然我们定义棍子的单次移动的距离为一个常数，但是考虑到代码的复用性已经后期设计的灵活，有可能会对棍子的移动距离作出改变，或者对它的大小作出改变，
在这种情况下，如果不对棍子在屏幕边界附近的移动作出限制，将会导致棍子的移动产生紊乱。解决的思路就是饱和加法器，向右边移动20，棍子的左右边界会同时移动20，如果没有那么多距离，
那么就会自动“饱和”，也就是让棍子停留在边界上，而不会使得运行出错。

上面考虑边界附近的移动的情况，同样也适用于小球的移动。所以小球在边界附近的移动也要加入这样的限制条件

下一步我们是要让球有弹力，在碰到四周的墙壁时改变速度。
一开始我们想到利用入射角等于反射角这一概念对球的碰撞方式进行建模，但是，这个方法对于硬件来说，会消耗大量的资源来计算和存储一个角度，
并且只能实现角度是整数的情况。略加思考我们决定采用把速度分解成为水平和垂直分量的方法。

根据物理模型，并简化，我们将小球的速度分解为水平和垂直，并且碰撞没有能量损耗。
所以在碰撞左右时，水平速度反向，在碰撞上下时，则有垂直速度的反向。

我们在进行碰撞的实验时发现，小球会于碰撞点停下，在使用波形图分析后，是因为用条件对速度直接进行更新，会导致紊乱，
要解决，就要在速度的更新上延迟一个时钟周期，所以我们设计了两个寄存器用来存放小球的下一时刻（帧）的位置和速度。
小球的状态更新流程：速度信息+位置信息——》下一时刻的 速度信息+位置信息存于寄存器——》把寄存器信息更新到现在的状态上。

当小球碰到下面的边界后，游戏将停止，本来想通过显示“game over”来指示游戏结束，但是这样做需要花费大量的硬件资源
对字母图案进行储存，又想过利用数码管的跳动显示来指示，最后决定利用屏幕上的游戏界面的背景颜色的改变来指示，既简单，又明了。
----------------------------------------------------------------------

